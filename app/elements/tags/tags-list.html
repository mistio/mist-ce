<link rel="import" href="../../bower_components/polymer/polymer.html">
<link rel="import" href="../../bower_components/paper-button/paper-button.html">
<link rel="import" href="../../bower_components/paper-styles/typography.html">
<link rel="import" href="../../bower_components/neon-animation/animations/scale-up-animation.html">
<link rel="import" href="../../bower_components/neon-animation/animations/fade-out-animation.html">
<link rel="import" href="../../bower_components/paper-progress/paper-progress.html">

<link rel="import" href="tag-item.html">

<dom-module id="tags-list">
    <template>
        <style is="custom-style" include="dialogs"></style>
        <style include="shared-styles">
            :host {
                display: block;
                width: 100%;
            }

            .tag-list {
                padding: 0 0 24px 0;
            }

            .bottom-actions {
                padding-bottom: 2px;
                margin-top: 16px;
                overflow: hidden;
                vertical-align: middle;
                display: block;
                width: 100%;
            }

            paper-dialog {
                width: 450px;
            }

            paper-button {
                display: inline;
            }

            .pull-right {
                float: right;
            }

            .submit-btn.add {
                line-height: 40px;
                margin: 0;
            }

            .submit-btn.save {
                padding-left: 16px;
                padding-right: 16px;
            }
            #progress {
                margin-bottom: 16px;
                margin-top: 0;
                border-bottom: 1px solid #ddd;
            }
            #errormsg {
                color: var(--red-color) !important;
                padding: 16px 24px;
            }
            #progress paper-progress {
                width: 100%;
                margin: 0 auto;
            }
            #progress paper-progress[error]>::content #primaryProgress {
                background-color: var(--red-color) !important;
            }
        </style>

        <paper-dialog id="tagsModal" entry-animation="scale-up-animation" exit-animation="fade-out-animation" with-backdrop>
            <h2>Tags</h2>
            <paper-dialog-scrollable>
                <div class="tag-list">
                    <template is="dom-repeat" items="[[tags]]" as="tag">
                        <tag-item tag="[[tag]]" index=[[index]]></tag-item>
                    </template>
                </div>
            </paper-dialog-scrollable>
            <div id="progress">
                <paper-progress indeterminate hidden$="[[!showProgress]]"></paper-progress>
                <paper-progress error hidden$="[[!hasError]]"></paper-progress>
                <div id="errormsg" hidden$="[[!hasError]]"></div>
            </div>

            <div class="clearfix bottom-actions xs12">
                <paper-button class="submit-btn add" on-tap="_addTag">
                    <iron-icon icon="add"></iron-icon> Add Tag</paper-button>
                <paper-button class="submit-btn pull-right blue save" on-tap="_saveTags">Save Tags</paper-button>
                <paper-button class="pull-right blue-link" dialog-dismiss>Cancel</paper-button>
            </div>
        </paper-dialog>
        <paper-toast></paper-toast>
        <iron-ajax id="tagsAjaxRequest" url="/api/v1/tags" method="POST" on-response="_handleTagsAjaxResponse" on-error="_handleTagsAjaxError"></iron-ajax>
    </template>

    <script>
        (function() {
            'use strict';

            Polymer({
                is: 'tags-list',

                properties: {
                    resource: String,
                    model: Object,
                    items: {
                        type: Array,
                        notify: true
                    },
                    tags: {
                        type: Array
                    },
                    tagsToDelete: {
                        type: Array
                    },
                    hasError: {
                        type: Boolean,
                        value: false
                    },
                    showProgress: {
                        type: Boolean,
                        value: false
                    }
                },
                observers: [
                    'selectedItemsChanged(items.splices, items.length)',
                    '_computeTags(items)'
                ],
                listeners: {
                    'iron-overlay-closed': '_modalClosed',
                    'tag-delete': '_tagDeleteHandler',
                    'tag-change': '_tagUpdate'
                },
                ready: function(){
                    this.set('items', []);
                    this.set('tags', []);
                    this.set('tagsToDelete', []);
                },
                _openDialog: function(e) {
                    this.querySelector('paper-dialog').open();
                },
                _closeDialog: function() {
                    this.querySelector('paper-dialog').close();
                },
                _modalClosed: function(e) {
                    this.set('tagsToDelete', []);
                    this.set('showProgress', false);
                    this.set('hasError', false);
                    this.$.errormsg.textContent = '';
                },
                selectedItemsChanged: function(items, length){
                    this._computeTags(this.items);
                },
                _computeTags: function(items) {
                    var tags = this._computeCommonTags(this.items);
                    if (!tags.length) {
                        tags = [{
                            key: '',
                            value: ''
                        }];
                    }

                    this.set('tags', tags);
                },
                _computeCommonTags: function(items) {
                    var tags = [],
                        tagset = new swiftSet.Set(),
                        isection = new swiftSet.Set();

                    for (var i = 0; i < items.length; i++) {

                        var item = items[i];

                        var itemType = item.split(":")[0],
                            itemCloudId = item.split(":")[1],
                            itemId = item.split(":")[2],
                            itemObj = {}; 
                            
                        if (['machine', 'image', 'network'].indexOf(itemType) != -1 && itemCloudId)
                            itemObj = this.model.clouds[itemCloudId][itemType+'s'][itemId];
                        else {
                            itemObj = this.model[itemType+'s'][itemId];
                        }
                        if (itemObj) {

                            if (!itemObj.tags) 
                                itemObj.tags = [];
                            // TO FIX: network tags should not be type 'object', but Array of objects
                            // only networks return their tags in such format. Below code patches it.
                            else if (itemObj.tags && typeof(itemObj.tags) == 'object') {
                                var foo = []
                                for (var p in itemObj.tags) {
                                    foo.push(itemObj.tags[p])
                                }
                                itemObj.tags = foo;
                            }

                            if (i == 0) {
                                // console.log('itemObj.tags',itemObj.tags);
                                tagset.addItems(itemObj.tags.map(function(tag){
                                    return tag.key+'='+tag.value;
                                }));
                            }
                            else {
                                isection.clear()
                                isection.addItems(tagset.intersection(itemObj.tags.map(function(tag){
                                        return tag.key+'='+tag.value;
                                    }) || []));
                                tagset.clear();
                                tagset.addItems(isection.items());
                            }
                        }
                    }

                    return tagset.items().map(function(item){
                        return {key: item.split('=')[0],
                                value: item.split('=')[1]};
                    }) || [];
                },
                _addTag: function() {
                    var newTag = {
                        key: '',
                        value: ''
                    };
                    this.push('tags', newTag);
                },
                _tagDeleteHandler: function(e) {
                    var tag = e.detail.tag,
                        index = this.tags.indexOf(tag);
                    this.splice('tags', index, 1);

                    tag.op = "-";
                    this.push('tagsToDelete', tag);
                    console.log(this.tagsToDelete);
                },
                _tagUpdate: function(e){
                    // this._tagDeleteHandler(e);
                    console.log(e.detail);

                    var oldTag = e.detail.oldTag;
                    var newTag = e.detail.newTag;

                    //move old tag to tags to delete
                    if (oldTag.key != newTag.key){
                        oldTag.op = "-";
                        this.push('tagsToDelete', oldTag);
                    }
                },
                _saveTags: function() {
                    // console.log('_saveTags', this.items);
                    var newTags = this.tags.filter(function(tag) {
                            return tag.key;
                        }),
                        payload = [];

                    payload = this.items.map(function(item) {
                        var itemType = item.split(":")[0],
                            itemCloudId = item.split(":")[1],
                            itemId = item.split(":")[2],
                            itemObj;
                        
                        if (['machine', 'image', 'network'].indexOf(itemType) != -1 && itemCloudId)
                            itemObj = this.model.clouds[itemCloudId][itemType+'s'][itemId];
                        else {
                            itemObj = this.model[itemType+'s'][itemId];
                        }

                        var newItem = {};

                        newItem.resource = {
                            type: itemType,
                            item_id: itemId,
                            cloud_id: ['machine', 'image', 'network'].indexOf(itemType) != -1 ? itemCloudId : ''
                        };
                        newItem.tags = newTags;

                        if (this.tagsToDelete.length > 0) {
                            this.tagsToDelete.forEach(function(tag){
                                newItem.tags.push(tag);
                            })
                        }
                        return newItem;
                    }, this);
                    console.log('payload',payload);

                    this.$.tagsAjaxRequest.body = payload;
                    this.$.tagsAjaxRequest.headers["Content-Type"] = 'application/json';
                    this.$.tagsAjaxRequest.headers["Csrf-Token"] = CSRF_TOKEN;
                    this.$.tagsAjaxRequest.generateRequest();

                    this.set('showProgress', true);
                },
                _handleTagsAjaxResponse: function(e) {
                    this._closeDialog();
                    this._showToast('Tags were updated!');
                },
                _handleTagsAjaxError: function(e){
                    console.log(e.detail.error.message);
                    this.set('showProgress', false);
                    this.set('hasError', true);
                    this.$.errormsg.textContent = e.detail.error.message;
                },
                _showToast: function(msg) {
                    var toast = this.querySelector('paper-toast');
                    toast.text = msg;
                    toast.show();
                }
            });
        })();
    </script>
</dom-module>
