<link rel="import" href="../../bower_components/vaadin-grid/vaadin-grid.html">
<link rel="import" href="../../bower_components/vaadin-combo-box/vaadin-combo-box.html">
<dom-module id="log-list">
    <template>
      <style>
          vaadin-combo-box {
            padding: 8px; 
          }
          .head {
            padding: 0 16px 16px 24px;
            align-items: flex-end;
          }
          vaadin-combo-box {
            padding-top: 0;
          }
          vaadin-grid {
            border-top: 1px solid #ddd;
          }
      </style>
      <paper-material>
        <div class="head layout horizontal">
          <h3 class="flex">LOGS</h3>
          <vaadin-combo-box class="flex" label="Filter logs" items="[[logFilterSuggestions]]" allow-custom-value on-value-change="_updateFilter"></vaadin-combo-box>
        </div>
        <vaadin-grid size="10000">
        </vaadin-grid>
      </paper-material>
    </template>
</dom-module>

<script>
Polymer({
    is: 'log-list',

    properties: {
        items: {
            type: Array,
            value: []
        },

        filteredItems: {
            type: Array,
            value: []
        },

        stop: {
            type: Number,
            value: 0
        },

        limit: {
            type: Number,
            value: 50
        },

        filter: {
            type: Object,
        },

        logFilterSuggestions: {
            type: Array,
            value: ['type:job', 'type:request', 'type:incident', 'type:session', 'type:shell', 'error']
        }
    },

    ready: function() {
        var socket = document.querySelector('app-socket'), that = this, requestPending = false;
        if (!socket || !socket.get('initialized')) {
            setTimeout(function() {
              that.ready();
            }, 1000);
            console.debug('postpone log-list init until socket is ready');
            return
        }
        this.grid = this.querySelector('vaadin-grid');
        this.grid.items = function(params, callback) {
            that.filteredItems = that.items.filter(that._filter.bind(that));
            if (params.index + params.count < that.get('filteredItems.length')) {
                callback(that.get('filteredItems').slice(params.index, params.index + params.count));
            } else if (!requestPending) {
                var pending = false;
                // Fetch the JSON data from a URL
                var xhr = new XMLHttpRequest();
                xhr.onreadystatechange = function() {
                    requestPending = false;
                    if (xhr.readyState == XMLHttpRequest.DONE) {
                        if (xhr.status == 200) {
                            var entries = JSON.parse(xhr.responseText);
                            for (i=0; i < entries.length; i++)
                                that.push('items', entries[i]);
                            that.filteredItems = that.items.filter(that._filter.bind(that));
                            callback(that.filteredItems.slice(params.index, params.index + params.count));
                            if (that.filteredItems.length > that.grid.size)
                                that.grid.size=2*that.grid.size;

                            if (that.items.length) {
                                var stop = Math.floor(that.items[that.items.length-1].time);
                                that.set('stop', stop);
                            }
                            that._updateColumns(items);
                        }
                    }
                }
                xhr.open("GET", '/api/v1/logs?stop=' + that.get('stop') + "&limit=" + that.get('limit'), true);
                xhr.send();
                requestPending = true;
            };
        };

        this.grid.columns = [
          {name: 'action', },
          {name: 'type'},
          {name: 'time', renderer:
              function(cell) {
                  //var item = that.items.find(function(p){ return p.time==cell.data});
                  //var ind = that.items.indexOf(item);
                  var dt = new Date(cell.data * 1000);
                  cell.element.innerHTML = /*ind + ' : ' + cell.data + ' : ' + */ dt.getTimeFromNow();
                  //console.info(dt, dt.getTimeFromNow());
              }
          }
        ];
        // Add a row details generator
        this.grid.rowDetailsGenerator = function(rowIndex) {
          var elem = document.createElement('div');
          elem.setAttribute('class', 'logdetailswrapper');

          that.grid.getItem(rowIndex, function(error, item) {
              if (!error) {
                  // Start with the special fields
                  var rows = "<tr><td>Date</td><td>" + item.time + "</td></tr>";
                  var keys = Object.keys(item);
                  for (var i=0;i<keys.length;i++) {
                        // Display non special fields only
                        if (['time','$H'].indexOf(keys[i]) > -1)
                            continue
                      rows += "<tr><td>" + keys[i] + "</td><td>" + YAML.dump(item[keys[i]]) + "</td>";
                  }
                  elem.innerHTML = "<table style='width: 100%'>" + rows + "</table>";
              }
          });

          return elem;
        };

        var detailsOpenIndex = -1;

        // Show details for the selected row
        this.grid.addEventListener('selected-items-changed', function() {
          that.grid.setRowDetailsVisible(detailsOpenIndex, false);
          var selected = that.grid.selection.selected();
          if (selected.length == 1) {
            that.grid.setRowDetailsVisible(selected[0], true);
            detailsOpenIndex = selected[0];
          }
        });

        var combobox = this.querySelector('vaadin-combo-box');
        combobox.addEventListener('value-changed', this._updateRemoteFilter);
        combobox.addEventListener('keydown', this._updateLocalFilter);

        setInterval(function() {that.grid.refreshItems()}, 10000);

      },

      eventReceived: function(entry) {
          this.unshift('items', entry);
          this.grid.refreshItems();
          this._updateColumns([entry]);
      },

      _updateColumns: function(items) {
          var Set = swiftSet.Set;
          var allKeys = new Set(), allTypes = new Set(), allActions = new Set();
          for (var i=0;i<items.length;i++) {
              allKeys.addItems(Object.keys(items[i]));
              allTypes.add('type:' + items[i].type);
              allActions.add('action:' + items[i].action);
          }

          var existingColumns = new Set();
          for (var i=0;i<this.grid.columns.length;i++) {
              existingColumns.add(this.grid.columns[i].name);
          }

          var keyItems = allKeys.items()
          for (var i=0;i<keyItems.length;i++)
              if (!existingColumns.has(keyItems[i]))
                  this.grid.addColumn({name: keyItems[i], hidden: true, hidable: true})

          var logFilterSuggestions = new Set(this.get('logFilterSuggestions')).union(allActions);

          this.set('logFilterSuggestions', logFilterSuggestions);
      },

      _updateRemoteFilter: function(data) {
          var value = this.querySelector('input').value;

          console.warn('_updateRemoteFilter', data);
      },

      _updateLocalFilter: function(data) {
          var value = this.querySelector('input').value;
          if (this.grid)
              this.grid.refreshItems();
          console.warn('_updateLocalFilter', data, this);
      },

      _filter(item) {
          var filterString = this.querySelector('input').value,
              filterArray = filterString.split(' ');
              for (var i=0;i<filterArray.length;i++){
                  if (filterArray[i].indexOf(':')>-1){
                      var filterMap = filterArray[i].split(':');
                      if (item[filterMap[0]] && item[filterMap[0]].indexOf(filterMap[1]) == -1)
                          return false
                  } else {
                      if (JSON.stringify(item).indexOf(filterArray[i]) == -1)
                          return false
                  }
              }
          return true
      }
});

var TIME_MAP = {
    SECOND: 1000,
    MINUTE: 60 * 1000,
    HOUR: 60 * 60 * 1000,
    DAY: 24 * 60 * 60 * 1000,
    WEEK: 7 * 24 * 60 * 60 * 1000,
    MONTH: 30 * 24 * 60 * 60 * 1000,
    YEAR: 12 * 30 * 24 * 60 * 60 * 1000,
};

Date.prototype.getTimeFromNow = function () {
    var now = new Date();
    var diff = now - this;
    var ret = '';

    if (diff < 10 * TIME_MAP.SECOND)
        ret = 'Now';

    else if (diff < TIME_MAP.MINUTE)
        ret = parseInt(diff / TIME_MAP.SECOND) + ' sec';

    else if (diff < TIME_MAP.HOUR)
        ret = parseInt(diff / TIME_MAP.MINUTE) + ' min';

    else if (diff < TIME_MAP.DAY)
        ret = parseInt(diff / TIME_MAP.HOUR) + ' hour';

    else if (diff < 2 * TIME_MAP.DAY)
        ret = 'Yesterday';

    else if (diff < TIME_MAP.YEAR)
        ret = this.getMonthName(true) +  ' ' + this.getDate();

    if (ret.indexOf('sec') > -1 ||
        ret.indexOf('min') > -1 ||
        ret.indexOf('hour') > -1) {

        // Add 's' for plural
        if (ret.split(' ')[0] != '1')
            ret = ret + 's';

        ret = ret + ' ago';
    }

    return ret;
}
</script>
